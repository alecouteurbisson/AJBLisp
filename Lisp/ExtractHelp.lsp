;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Extract Lisp function help from func.cpp
;;;; Generates the file LispHelp.rtf which can be read with
;;;; Word or Quickview (among others).
;;;; Note: RTF formatting created without the help of a manual
;;;;       but the result looks OK so I guess its right!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Open files as infile1/2 and outfile
(defun open-files nil
  (setq infile1 (open-file "func.cpp" :read))
  (when (null infile1)
    (error 1 "func.cpp" "Can't open input file") )

  (setq infile2 (open-file "gfunc.cpp" :read))
  (when (null infile2)
    (error 1 "gfunc.cpp" "Can't open input file") )

  (setq outfile (open-file "LispHelp.rtf" :create))
  (when (null outfile)
    (error 1 "LispHelp.rtf" "Can't open output file") ))

;;; ...and cleanup
(defun close-files nil
  (close-file infile1)
  (close-file infile2)
  (close-file outfile) )

;;; Define some flags
(defkey :func)
(defkey :macr)
(defkey :desc)
(defkey :exam)

;;; Read the next line of help
;;; Returns a list of :func, :macr, :desc or :exam followed by the trimmed line
;;; Returns nil at EOF
(defun get-help-line nil
  (let ((line)(hdr))
       (loop (while (not (eof infile)) nil)
             (setq line (readline infile))
             (setq hdr (substring line 0 4))
             (until (eql hdr "//f ")
                    (list :func (escape (substring line 3))) )
             (until (eql hdr "//m ")
                    (list :macr (escape (substring line 3))) )
             (until (eql hdr "//$ ")
                    (list :desc (escape (substring line 4))) )
             (until (eql hdr "//x ")
                    (list :exam (escape (substring line 4))) ))))

;;; Escape any backslashes
(defun escape (s)
   (if (not (string-search s #\\))
       s
       (string (do-escape (chars s))) ))

;;; Destructively insert escape backslashes into a list of characters
(defun do-escape (c)
  (let ((ci c)(temp))
       (loop
         (while ci c)
         (when (eql (car ci) #\\)
           (setq temp (cons #\\ (cdr ci)))
           (rplacd ci temp)
           (pop ci) )
         (pop ci) )))

;;; Scan for help lines and collect them for formatting
(defun scan-help nil
  (let ((func) (desc) (exam) (line) (count 0))
       (loop
          (setq line (get-help-line))
          (until (null line)
                 (print-help func desc exam)
                 count )
          (cond
            ((member (car line)                ; Got a new header?
                     '(:func :macr) )
             (when func
               (print-help func desc exam) )   ; Print the last one


             ;; Setup for the next entry and set its type
             (setq func
                  (concat (toc-entry (cadr line))
                          (if (eq (car line) :func)
                              "Function "
                              "Macro    " )
                          (cadr line) ))
             (setq desc nil)
             (setq exam nil) )

            ((eq (car line) :desc)             ; Collect description lines
             (push (cadr line) desc) )

            ((eq (car line) :exam)             ; Collect example lines
             (push (cadr line) exam) )))))

;;; Print help for one function
(defun print-help (func desc exam)
  (inc count)
  (print-func func)
  (print-desc (reverse desc))                  ; These have been pushed in reverse order
  (print-exam (reverse exam))                  ; ...as have these
  (println outfile "\\par\\par") )

;;; Print the parts of the help output
(defun print-func (func)
  (println outfile "\\par {\\b\\f0\\fs24 ")
  (println outfile func)
  (println outfile "}") )

(defun print-desc (desc)
  (println outfile "\\par {\\f0\\fs20 ")
  (loop (while desc)
        (println outfile (pop desc) " ") )
  (println outfile "}") )

(defun print-exam (exam)
  (when exam
    (println outfile "\\par {\\f1\\fs20 ")
    (println outfile "{\\b Examples: }")
    (loop (while exam)
          (println outfile "\\par " (pop exam)) )
    (println outfile "}") ))

(defun print-rtf-header nil
  (println outfile "{\\rtf1\\ansi \\deff0\\deflang1024")
  (println outfile "{\\fonttbl")
  (println outfile "{\\f0 Lucida Sans;}")
  (println outfile "{\\f1 Lucida Console;} }")
  (println outfile "{\\f0\\fs36\\b AJBLisp Function Reference}\\par")
  (println outfile "{\\f0\\fs20 Generated by ExtractHelp.lsp}\\par")
  (println outfile (concat "{\\f0\\fs20 {on: "
                           (time-string "%#c %Z")
                           "}}\\par\\par" ))
  (println outfile "{\\f0\\fs20 Key to function headers}\\par")
  (println outfile "{\\f0\\fs20    {\\b[}optional_arguments{\\b]}}\\par")
  (println outfile "{\\f0\\fs20    one_or_more{\\b...}}\\par")
  (println outfile "{\\f0\\fs20    {\\b[}zero_or_more{\\b...]}}\\par\\par")

  (println outfile "{\\field \\flddirty {\\*\\fldinst INDEX \\h \" \" \\c \"2\"}")
  (println outfile "{\\fldrslt Table of Contents }}")

;  (println outfile "{\\field \\flddirty {\\*\\fldinst TOC \\\\f \\\\h \\\\z }")
;  (println outfile "{\\fldrslt Table of Contents }}")
  (println outfile "\\par\\par") )

(defun print-rtf-footer nil
  (println outfile "}") )

(defun toc-entry (line)
  (setq line (substring line 2))
  (setq line (substring line 0 (string-search line " ()")))
  ;(when (= (length line) 1)
  ;      (setq line (concat " " line)) )
  (concat "{\\xe\\v{\\f0\\fs10{\\i " line "}}}") )

;;; Put it all together...
(defun extract-help nil
  (guard
    (let ((infile1)(infile2)(infile)(outfile))
      (open-files)
      (setq infile infile1)   ; Scan func.cpp
      (print-rtf-header)
      (setq funcount (scan-help))
      (setq infile infile2)   ; Scan gfunc.cpp
      (inc funcount (scan-help))
      (println funcount " functions processed.")
      (print-rtf-footer)
      (close-files) )))

;;; ...and from the top...
(extract-help)

;; Close if launched from an icon
(when (scripted)
  (sleep 5000)
  (exit) )
