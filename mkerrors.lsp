;; Under Construction!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some macros to compile the list of errors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro err (n code msg)
  (setq errno n)
  (push (list n code msg) *errors*) )

(defmacro -err (code msg)
  (dec errno)
  (push (list errno code msg) *errors*) )

(defmacro +err (code msg)
  (inc errno)
  (push (list errno code msg) *errors*) )

(defmacro // (comment)
  (push (list '// comment) *errors*) )

; Dcelare these globals
(setq *errors* nil)
(setq *errno* 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The errors and comments
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(// "Fatal errors")
(err 0    FATAL_EXIT           "")
(-err     FATAL_HEAP           "Failed to allocate heap")
(-err     FATAL_STACK          "Failed to allocate stack")
(-err     FATAL_HEAP_OVF       "Out of heap space")
(-err     FATAL_STACK_OVF      "Out of stack space")
(-err     FATAL_BAD_STACK      "Corrupted lisp stack")
(// "Non-fatal error messages")
(err 1    ERR_PROG             "Programmed error")
(+err     ERR_USER             "User interrupt")
(+err     ERR_NUM_ARGS         "Incorrect number of arguments to function")
(+err     ERR_LIST_EXP         "List argument expected")
(+err     ERR_NUM_EXP          "Numeric argument expected")
(+err     ERR_INT_EXP          "Integer argument expected")
(+err     ERR_REAL_EXP         "Real argument expected")
(+err     ERR_SYM_EXP          "Symbol argument expected")
(+err     ERR_KEY_EXP          "Key argument expected")
(+err     ERR_CHR_EXP          "Character argument expected")
(+err     ERR_STR_EXP          "String argument expected")
(+err     ERR_FILE_EXP         "File argument expected")
(+err     ERR_ATOM_EXP         "Atomic argument expected")
(+err     ERR_VEC_EXP          "Vector argument expected")
(+err     ERR_INV_KEY          "Invalid key argument")
(+err     ERR_BAD_FUNC         "Illegal function")
(+err     ERR_BAD_MAC          "Illegal macro")
(+err     ERR_BAD_FORMAL       "Illegal formal argument")
(+err     ERR_IMMUTABLE        "Cannot change value of a constant")
(+err     ERR_BAD_ASSOC        "Badly formed association list")
(+err     ERR_BAD_PLIST        "Badly formed property list")
(+err     ERR_NULL_LOOP        "Aborted null loop")
(+err     ERR_NUM_FORMAL       "Too many arguments for stack frame")
(+err     ERR_BAD_REAL         "Cannot interpret string as real")
(+err     ERR_BAD_INT          "Cannot interpret string as integer")
(+err     ERR_BAD_ARG          "Invalid argument(s)")
(+err     ERR_LET_BIND         "Badly formed binding in LET")
(+err     ERR_BAD_CASE         "Badly formed case expression")
(+err     ERR_NO_CASE          "No matching case found")
(+err     ERR_BAD_ASCII        "Illegal ASCII value")
(+err     ERR_STR_LEN          "String buffer overflow")
(+err     ERR_SYM_LEN          "Symbol name too long")
(+err     ERR_BAD_TYP          "Unrecognised argument type")
(+err     ERR_CATCH            "Throw not caught")
(+err     ERR_BIT_NUM          "Illegal bit number")
(+err     ERR_VEC_IDX          "Vector/List/String index out of range")
(+err     ERR_VEC_DIM          "Vector dimension must be a whole number")
(// "Maths errors")
(// "Maths errors raised within the interpreter will have more")
(// "helpful error messages which specify the function that")
(// "failed.  These messages are provided for user.")
(err 100  ERR_M_DOM            "Maths - domain error")
(+err     ERR_M_SING           "Maths - result singular")
(+err     ERR_M_OVRF           "Maths - result overflow")
(+err     ERR_M_UNDF           "Maths - result underflow")
(+err     ERR_M_INAC           "Maths - result inaccurate")
(+err     ERR_M_INV            "Maths - invalid operation")
(+err     ERR_M_DIVZ           "Maths - divide by zero")
(+err     ERR_M_IOVF           "Maths - integer overflow")
(+err     ERR_M_UNK            "Maths - unknown error")
(// "I/O errors")
(err 200  ERR_EOF_ESC          "EOF after reading escape character")
(+err     ERR_EOF_STR          "EOF inside string")
(+err     ERR_EOF_LIST         "EOF inside list")
(+err     ERR_STR_CHR          "Illegal character inside string")
(+err     ERR_BAD_RPAR         "Unexpected close parenthesis")
(+err     ERR_NO_RPAR          "Missing close parenthesis")
(+err     ERR_PATOM            "List argument to patom")
(+err     ERR_TOK_LEN          "Input token exceeds buffer size (241 characters)")
(+err     ERR_BAD_RMAC         "Illegal input after '#'")
(+err     ERR_UNREADABLE       "Unreadable input; #<...>")
(+err     ERR_PRT_BUF          "Output buffer overflow")
(+err     ERR_KBD_BUF          "Keyboard buffer underflow")
(// "Filesystem errors")
(err 300  ERR_DISC_FAULT       "Disc fault")
(+err     ERR_PERMISSION       "Permission denied")
(+err     ERR_LONG_PATH        "Path too long")
(+err     ERR_NOT_DIR          "File/Directory not found")
(+err     ERR_KMEM             "Insufficient kernel memory")
(+err     ERR_NUM_LINKS        "Too many links")
(+err     ERR_INV_OP           "Invalid Operation")
(+err     ERR_DISK_FULL        "No space on disc")
(// "Unknown error")
(err 998  ERR_UNKNOWN          "Unknown error")
(// "Debug")
(err 999  ERR_DEBUG            "Debug error")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Process the list of errors and generate the C++ files
;; and the errors help file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reverse *errors* which has been compiled in reverse order
(setq *errors* (reverse *errors*))

(defun make-lisperr.h nil
  (let ((f (open-file "test-lisperr.h" :create)))
    (if (not f) (error 1 :none "Cannot open test-lisperr.h"))
    (guard
      (print-warning f)
      (println f "#ifndef LisperrH")
      (println f "#define LisperrH")
      (println f "enum LERROR {")
      (for-each (err *errors*)
        (cond
          ((eq (car err) '//)
           (print f '// :space (cadr err)))
          (t
           (print f "   " (cadr err) " = " (car err))
           (unless (= (car err) 999) (print f ",")) ))
        (println f) )
      (println f "}")
      (println f "const char* err_msg(LERROR e);")
      (println f "void DefineErrorConst();")
      (println f "#endif")
      (close-file f) )))


(defun print-warning (f)
  (println f "// Generated file - DO NOT EDIT")
  (println f "// Edit errors.in to make changes") )

(make-lisperr.h)
(exit)
